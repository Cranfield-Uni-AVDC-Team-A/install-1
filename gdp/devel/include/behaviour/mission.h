// Generated by gencpp from file behaviour/mission.msg
// DO NOT EDIT!


#ifndef BEHAVIOUR_MESSAGE_MISSION_H
#define BEHAVIOUR_MESSAGE_MISSION_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace behaviour
{
template <class ContainerAllocator>
struct mission_
{
  typedef mission_<ContainerAllocator> Type;

  mission_()
    : header()
    , points(0)
    , lat1(0.0)
    , lat2(0.0)
    , lat3(0.0)
    , lat4(0.0)
    , lat5(0.0)
    , lat6(0.0)
    , lat7(0.0)
    , lat8(0.0)
    , lon1(0.0)
    , lon2(0.0)
    , lon3(0.0)
    , lon4(0.0)
    , lon5(0.0)
    , lon6(0.0)
    , lon7(0.0)
    , lon8(0.0)
    , alt1(0.0)
    , alt2(0.0)
    , alt3(0.0)
    , alt4(0.0)
    , alt5(0.0)
    , alt6(0.0)
    , alt7(0.0)
    , alt8(0.0)  {
    }
  mission_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , points(0)
    , lat1(0.0)
    , lat2(0.0)
    , lat3(0.0)
    , lat4(0.0)
    , lat5(0.0)
    , lat6(0.0)
    , lat7(0.0)
    , lat8(0.0)
    , lon1(0.0)
    , lon2(0.0)
    , lon3(0.0)
    , lon4(0.0)
    , lon5(0.0)
    , lon6(0.0)
    , lon7(0.0)
    , lon8(0.0)
    , alt1(0.0)
    , alt2(0.0)
    , alt3(0.0)
    , alt4(0.0)
    , alt5(0.0)
    , alt6(0.0)
    , alt7(0.0)
    , alt8(0.0)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef int8_t _points_type;
  _points_type points;

   typedef double _lat1_type;
  _lat1_type lat1;

   typedef double _lat2_type;
  _lat2_type lat2;

   typedef double _lat3_type;
  _lat3_type lat3;

   typedef double _lat4_type;
  _lat4_type lat4;

   typedef double _lat5_type;
  _lat5_type lat5;

   typedef double _lat6_type;
  _lat6_type lat6;

   typedef double _lat7_type;
  _lat7_type lat7;

   typedef double _lat8_type;
  _lat8_type lat8;

   typedef double _lon1_type;
  _lon1_type lon1;

   typedef double _lon2_type;
  _lon2_type lon2;

   typedef double _lon3_type;
  _lon3_type lon3;

   typedef double _lon4_type;
  _lon4_type lon4;

   typedef double _lon5_type;
  _lon5_type lon5;

   typedef double _lon6_type;
  _lon6_type lon6;

   typedef double _lon7_type;
  _lon7_type lon7;

   typedef double _lon8_type;
  _lon8_type lon8;

   typedef float _alt1_type;
  _alt1_type alt1;

   typedef float _alt2_type;
  _alt2_type alt2;

   typedef float _alt3_type;
  _alt3_type alt3;

   typedef float _alt4_type;
  _alt4_type alt4;

   typedef float _alt5_type;
  _alt5_type alt5;

   typedef float _alt6_type;
  _alt6_type alt6;

   typedef float _alt7_type;
  _alt7_type alt7;

   typedef float _alt8_type;
  _alt8_type alt8;





  typedef boost::shared_ptr< ::behaviour::mission_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::behaviour::mission_<ContainerAllocator> const> ConstPtr;

}; // struct mission_

typedef ::behaviour::mission_<std::allocator<void> > mission;

typedef boost::shared_ptr< ::behaviour::mission > missionPtr;
typedef boost::shared_ptr< ::behaviour::mission const> missionConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::behaviour::mission_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::behaviour::mission_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::behaviour::mission_<ContainerAllocator1> & lhs, const ::behaviour::mission_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.points == rhs.points &&
    lhs.lat1 == rhs.lat1 &&
    lhs.lat2 == rhs.lat2 &&
    lhs.lat3 == rhs.lat3 &&
    lhs.lat4 == rhs.lat4 &&
    lhs.lat5 == rhs.lat5 &&
    lhs.lat6 == rhs.lat6 &&
    lhs.lat7 == rhs.lat7 &&
    lhs.lat8 == rhs.lat8 &&
    lhs.lon1 == rhs.lon1 &&
    lhs.lon2 == rhs.lon2 &&
    lhs.lon3 == rhs.lon3 &&
    lhs.lon4 == rhs.lon4 &&
    lhs.lon5 == rhs.lon5 &&
    lhs.lon6 == rhs.lon6 &&
    lhs.lon7 == rhs.lon7 &&
    lhs.lon8 == rhs.lon8 &&
    lhs.alt1 == rhs.alt1 &&
    lhs.alt2 == rhs.alt2 &&
    lhs.alt3 == rhs.alt3 &&
    lhs.alt4 == rhs.alt4 &&
    lhs.alt5 == rhs.alt5 &&
    lhs.alt6 == rhs.alt6 &&
    lhs.alt7 == rhs.alt7 &&
    lhs.alt8 == rhs.alt8;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::behaviour::mission_<ContainerAllocator1> & lhs, const ::behaviour::mission_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace behaviour

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::behaviour::mission_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::behaviour::mission_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::behaviour::mission_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::behaviour::mission_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::behaviour::mission_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::behaviour::mission_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::behaviour::mission_<ContainerAllocator> >
{
  static const char* value()
  {
    return "f50631df6e5a5b429641093d499b4615";
  }

  static const char* value(const ::behaviour::mission_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xf50631df6e5a5b42ULL;
  static const uint64_t static_value2 = 0x9641093d499b4615ULL;
};

template<class ContainerAllocator>
struct DataType< ::behaviour::mission_<ContainerAllocator> >
{
  static const char* value()
  {
    return "behaviour/mission";
  }

  static const char* value(const ::behaviour::mission_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::behaviour::mission_<ContainerAllocator> >
{
  static const char* value()
  {
    return "Header header\n"
"int8 points\n"
"float64 lat1\n"
"float64 lat2\n"
"float64 lat3\n"
"float64 lat4\n"
"float64 lat5\n"
"float64 lat6\n"
"float64 lat7\n"
"float64 lat8\n"
"float64 lon1\n"
"float64 lon2\n"
"float64 lon3\n"
"float64 lon4\n"
"float64 lon5\n"
"float64 lon6\n"
"float64 lon7\n"
"float64 lon8\n"
"float32 alt1\n"
"float32 alt2\n"
"float32 alt3\n"
"float32 alt4\n"
"float32 alt5\n"
"float32 alt6\n"
"float32 alt7\n"
"float32 alt8\n"
"\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
;
  }

  static const char* value(const ::behaviour::mission_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::behaviour::mission_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.points);
      stream.next(m.lat1);
      stream.next(m.lat2);
      stream.next(m.lat3);
      stream.next(m.lat4);
      stream.next(m.lat5);
      stream.next(m.lat6);
      stream.next(m.lat7);
      stream.next(m.lat8);
      stream.next(m.lon1);
      stream.next(m.lon2);
      stream.next(m.lon3);
      stream.next(m.lon4);
      stream.next(m.lon5);
      stream.next(m.lon6);
      stream.next(m.lon7);
      stream.next(m.lon8);
      stream.next(m.alt1);
      stream.next(m.alt2);
      stream.next(m.alt3);
      stream.next(m.alt4);
      stream.next(m.alt5);
      stream.next(m.alt6);
      stream.next(m.alt7);
      stream.next(m.alt8);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct mission_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::behaviour::mission_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::behaviour::mission_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "points: ";
    Printer<int8_t>::stream(s, indent + "  ", v.points);
    s << indent << "lat1: ";
    Printer<double>::stream(s, indent + "  ", v.lat1);
    s << indent << "lat2: ";
    Printer<double>::stream(s, indent + "  ", v.lat2);
    s << indent << "lat3: ";
    Printer<double>::stream(s, indent + "  ", v.lat3);
    s << indent << "lat4: ";
    Printer<double>::stream(s, indent + "  ", v.lat4);
    s << indent << "lat5: ";
    Printer<double>::stream(s, indent + "  ", v.lat5);
    s << indent << "lat6: ";
    Printer<double>::stream(s, indent + "  ", v.lat6);
    s << indent << "lat7: ";
    Printer<double>::stream(s, indent + "  ", v.lat7);
    s << indent << "lat8: ";
    Printer<double>::stream(s, indent + "  ", v.lat8);
    s << indent << "lon1: ";
    Printer<double>::stream(s, indent + "  ", v.lon1);
    s << indent << "lon2: ";
    Printer<double>::stream(s, indent + "  ", v.lon2);
    s << indent << "lon3: ";
    Printer<double>::stream(s, indent + "  ", v.lon3);
    s << indent << "lon4: ";
    Printer<double>::stream(s, indent + "  ", v.lon4);
    s << indent << "lon5: ";
    Printer<double>::stream(s, indent + "  ", v.lon5);
    s << indent << "lon6: ";
    Printer<double>::stream(s, indent + "  ", v.lon6);
    s << indent << "lon7: ";
    Printer<double>::stream(s, indent + "  ", v.lon7);
    s << indent << "lon8: ";
    Printer<double>::stream(s, indent + "  ", v.lon8);
    s << indent << "alt1: ";
    Printer<float>::stream(s, indent + "  ", v.alt1);
    s << indent << "alt2: ";
    Printer<float>::stream(s, indent + "  ", v.alt2);
    s << indent << "alt3: ";
    Printer<float>::stream(s, indent + "  ", v.alt3);
    s << indent << "alt4: ";
    Printer<float>::stream(s, indent + "  ", v.alt4);
    s << indent << "alt5: ";
    Printer<float>::stream(s, indent + "  ", v.alt5);
    s << indent << "alt6: ";
    Printer<float>::stream(s, indent + "  ", v.alt6);
    s << indent << "alt7: ";
    Printer<float>::stream(s, indent + "  ", v.alt7);
    s << indent << "alt8: ";
    Printer<float>::stream(s, indent + "  ", v.alt8);
  }
};

} // namespace message_operations
} // namespace ros

#endif // BEHAVIOUR_MESSAGE_MISSION_H
